var searchIndex = {};
searchIndex['tendril'] = {"items":[[0,"","tendril","",null,null],[3,"Tendril","","",null,null],[4,"SubtendrilError","","",null,null],[13,"OutOfBounds","","",0,null],[13,"ValidationFailed","","",0,null],[0,"fmt","","Marker types for formats.",null,null],[3,"Bytes","tendril::fmt","Marker type for uninterpreted bytes.",null,null],[3,"ASCII","","Marker type for ASCII text.",null,null],[3,"UTF8","","Marker type for UTF-8 text.",null,null],[3,"WTF8","","Marker type for WTF-8 text.",null,null],[0,"imp","","Implementation details.",null,null],[3,"Fixup","tendril::fmt::imp","Describes how to fix up encodings when concatenating.",null,null],[12,"drop_left","","",1,null],[12,"drop_right","","",1,null],[12,"insert_len","","",1,null],[12,"insert_bytes","","",1,null],[11,"default","","",1,{"inputs":[{"name":"fixup"}],"output":{"name":"fixup"}}],[8,"Format","tendril::fmt","Trait for format marker types.",null,null],[10,"validate","","Check whether the buffer is valid for this format.",2,null],[11,"validate_prefix","","Check whether the buffer is valid for this format.",2,null],[11,"validate_suffix","","Check whether the buffer is valid for this format.",2,null],[11,"validate_subseq","","Check whether the buffer is valid for this format.",2,null],[11,"fixup","","Compute any fixup needed when concatenating buffers.",2,null],[8,"SubsetOf","","Indicates that one format is a subset of another.",null,null],[11,"revalidate_subset","","Validate the *other* direction of conversion; check if\nthis buffer from the superset format conforms to the\nsubset format.",3,null],[8,"SliceFormat","","Indicates a format which corresponds to a Rust slice type,\nrepresenting exactly the same invariants.",null,null],[16,"Slice","tendril::fmt::SliceFormat","",null,null],[8,"Slice","tendril::fmt","Indicates a Rust slice type that has a corresponding format.",null,null],[16,"Format","tendril::fmt::Slice","",null,null],[10,"as_bytes","tendril::fmt","Access the raw bytes of the slice.",4,null],[10,"from_bytes","","Convert a byte slice to this kind of slice.",4,null],[11,"fmt","","",5,{"inputs":[{"name":"bytes"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",5,{"inputs":[{"name":"bytes"}],"output":{"name":"bytes"}}],[11,"clone","","",5,{"inputs":[{"name":"bytes"}],"output":{"name":"bytes"}}],[11,"validate","","",5,null],[6,"Slice","","",null,null],[6,"Format","","",null,null],[11,"fmt","","",6,{"inputs":[{"name":"ascii"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",6,{"inputs":[{"name":"ascii"}],"output":{"name":"ascii"}}],[11,"clone","","",6,{"inputs":[{"name":"ascii"}],"output":{"name":"ascii"}}],[11,"validate","","",6,null],[11,"validate_prefix","","",6,null],[11,"validate_suffix","","",6,null],[11,"validate_subseq","","",6,null],[11,"fmt","","",7,{"inputs":[{"name":"utf8"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",7,{"inputs":[{"name":"utf8"}],"output":{"name":"utf8"}}],[11,"clone","","",7,{"inputs":[{"name":"utf8"}],"output":{"name":"utf8"}}],[11,"validate","","",7,null],[11,"validate_prefix","","",7,null],[11,"validate_suffix","","",7,null],[11,"validate_subseq","","",7,null],[6,"Slice","","",null,null],[6,"Format","","",null,null],[11,"fmt","","",8,{"inputs":[{"name":"wtf8"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",8,{"inputs":[{"name":"wtf8"}],"output":{"name":"wtf8"}}],[11,"clone","","",8,{"inputs":[{"name":"wtf8"}],"output":{"name":"wtf8"}}],[11,"validate","","",8,null],[11,"validate_prefix","","",8,null],[11,"validate_suffix","","",8,null],[11,"validate_subseq","","",8,null],[11,"fixup","","",8,null],[11,"eq","tendril","",0,{"inputs":[{"name":"subtendrilerror"},{"name":"subtendrilerror"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"subtendrilerror"},{"name":"subtendrilerror"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"subtendrilerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"subtendrilerror"}],"output":{"name":"subtendrilerror"}}],[11,"clone","","",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"drop","","",9,{"inputs":[{"name":"tendril"}],"output":null}],[11,"deref","","",9,{"inputs":[{"name":"tendril"}],"output":{"name":"slice"}}],[11,"extend","","",9,{"inputs":[{"name":"tendril"},{"name":"i"}],"output":null}],[11,"eq","","",9,{"inputs":[{"name":"tendril"},{"name":"tendril"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"tendril"},{"name":"tendril"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"tendril"},{"name":"tendril"}],"output":{"name":"option"}}],[11,"cmp","","",9,{"inputs":[{"name":"tendril"},{"name":"tendril"}],"output":{"name":"ordering"}}],[11,"default","","",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"fmt","","",9,{"inputs":[{"name":"tendril"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",9,{"inputs":[{"name":"tendril"},{"name":"h"}],"output":null}],[11,"new","","Create a new, empty `Tendril` in any format.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"with_capacity","","Create a new, empty `Tendril` with a specified capacity.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":{"name":"tendril"}}],[11,"len32","","Get the length of the `Tendril`.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"u32"}}],[11,"is_shared","","Is the backing buffer shared?",9,{"inputs":[{"name":"tendril"}],"output":{"name":"bool"}}],[11,"is_shared_with","","Is the backing buffer shared with this other `Tendril`?",9,{"inputs":[{"name":"tendril"},{"name":"tendril"}],"output":{"name":"bool"}}],[11,"clear","","Truncate to length 0 without discarding any owned storage.",9,{"inputs":[{"name":"tendril"}],"output":null}],[11,"try_from_byte_slice","","Build a `Tendril` by copying a byte slice, if it conforms to the format.",9,null],[11,"as_bytes","","View as uninterpreted bytes.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"into_bytes","","Convert into uninterpreted bytes.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"as_superset","","View as a superset format, for free.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"into_superset","","Convert into a superset format, for free.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"try_as_subset","","View as a subset format, if the `Tendril` conforms to that subset.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"result"}}],[11,"try_into_subset","","Convert into a subset format, if the `Tendril` conforms to that subset.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"result"}}],[11,"try_as_other_format","","View as another format, if the `Tendril` conforms to that format.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"result"}}],[11,"try_into_other_format","","Convert into another format, if the `Tendril` conforms to that format.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"result"}}],[11,"try_push_bytes","","Push some bytes onto the end of the `Tendril`, if they conform to the\nformat.",9,null],[11,"push_tendril","","Push another `Tendril` onto the end of this one.",9,{"inputs":[{"name":"tendril"},{"name":"tendril"}],"output":null}],[11,"try_subtendril","","Attempt to slice this `Tendril` as a new `Tendril`.",9,{"inputs":[{"name":"tendril"},{"name":"u32"},{"name":"u32"}],"output":{"name":"result"}}],[11,"subtendril","","Slice this `Tendril` as a new `Tendril`.",9,{"inputs":[{"name":"tendril"},{"name":"u32"},{"name":"u32"}],"output":{"name":"tendril"}}],[11,"try_pop_front","","Try to drop `n` bytes from the front.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":{"name":"result"}}],[11,"pop_front","","Drop `n` bytes from the front.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":null}],[11,"try_pop_back","","Drop `n` bytes from the back.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":{"name":"result"}}],[11,"pop_back","","Drop `n` bytes from the back.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":null}],[11,"as_other_format_without_validating","","View as another format, without validating.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"into_other_format_without_validating","","Convert into another format, without validating.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"tendril"}}],[11,"from_byte_slice_without_validating","","Build a `Tendril` by copying a byte slice, without validating.",9,null],[11,"push_bytes_without_validating","","Push some bytes onto the end of the `Tendril`, without validating.",9,null],[11,"unsafe_subtendril","","Slice this `Tendril` as a new `Tendril`.",9,{"inputs":[{"name":"tendril"},{"name":"u32"},{"name":"u32"}],"output":{"name":"tendril"}}],[11,"unsafe_pop_front","","Drop `n` bytes from the front.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":null}],[11,"unsafe_pop_back","","Drop `n` bytes from the back.",9,{"inputs":[{"name":"tendril"},{"name":"u32"}],"output":null}],[11,"from_slice","","Build a `Tendril` by copying a slice.",9,{"inputs":[{"name":"tendril"},{"name":"slice"}],"output":{"name":"tendril"}}],[11,"push_slice","","Push a slice onto the end of the `Tendril`.",9,{"inputs":[{"name":"tendril"},{"name":"slice"}],"output":null}],[11,"deref_mut","","",9,null],[11,"write","","",9,null],[11,"write_all","","",9,null],[11,"flush","","",9,{"inputs":[{"name":"tendril"}],"output":{"name":"result"}}],[11,"fmt","","",9,{"inputs":[{"name":"tendril"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_str","","",9,{"inputs":[{"name":"tendril"},{"name":"str"}],"output":{"name":"result"}}],[11,"write_str","","",9,{"inputs":[{"name":"tendril"},{"name":"str"}],"output":{"name":"result"}}],[11,"pop_front_char","","Remove and return the first character, if any.",9,{"inputs":[{"name":"tendril"}],"output":{"name":"option"}}],[11,"pop_front_char_run","","Remove and return a run of characters at the front of the `Tendril`\nwhich are classified the same according to the function `classify`.",9,{"inputs":[{"name":"tendril"},{"name":"c"}],"output":{"name":"option"}}],[6,"ByteTendril","","`Tendril` for storing binary data.",null,null],[6,"StrTendril","","`Tendril` for storing native Rust strings.",null,null],[8,"SliceExt","","`Tendril`-related methods for Rust slices.",null,null],[11,"to_tendril","","Make a `Tendril` from this slice.",10,{"inputs":[{"name":"sliceext"}],"output":{"name":"tendril"}}],[11,"to_tendril","","Make a `Tendril` from this slice.",10,null]],"paths":[[4,"SubtendrilError"],[3,"Fixup"],[8,"Format"],[8,"SubsetOf"],[8,"Slice"],[3,"Bytes"],[3,"ASCII"],[3,"UTF8"],[3,"WTF8"],[3,"Tendril"],[8,"SliceExt"]]};
searchIndex['futf'] = {"items":[[0,"","futf","",null,null],[3,"Codepoint","","Represents a complete or partial UTF-8 codepoint.",null,null],[12,"bytes","","The bytes that make up the partial or full codepoint.",0,null],[12,"rewind","","Start of the codepoint in the buffer, expressed as an offset\nback from `idx`.",0,null],[12,"meaning","","Meaning of the partial or full codepoint.",0,null],[4,"Meaning","","Meaning of a complete or partial UTF-8 codepoint.",null,null],[13,"Whole","","We found a whole codepoint.",1,null],[13,"LeadSurrogate","","We found something that isn't a valid Unicode codepoint, but\nit *would* correspond to a UTF-16 leading surrogate code unit,\ni.e. a value in the range `U+D800` - `U+DBFF`.",1,null],[13,"TrailSurrogate","","We found something that isn't a valid Unicode codepoint, but\nit *would* correspond to a UTF-16 trailing surrogate code unit,\ni.e. a value in the range `U+DC00` - `U+DFFF`.",1,null],[13,"Prefix","","We found only a prefix of a codepoint before the buffer ended.",1,null],[13,"Suffix","","We found only a suffix of a codepoint before running off the\nstart of the buffer.",1,null],[5,"classify","","Describes the UTF-8 codepoint containing the byte at index `idx` within\n`buf`.",null,null],[11,"hash","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"meaning"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"meaning"}],"output":{"name":"meaning"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"codepoint"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"codepoint"}],"output":{"name":"codepoint"}}]],"paths":[[3,"Codepoint"],[4,"Meaning"]]};
searchIndex['mac'] = {"items":[[0,"","mac","# mac",null,null],[0,"test","","Macros for writing test suites.",null,null],[0,"mem","","Macros for low-level memory manipulation.",null,null],[0,"format","","Macros for string formatting.",null,null],[0,"syntax_ext","","Macros useful when writing procedural syntax extensions.",null,null],[0,"matches","","Pattern Matching macros.",null,null],[14,"test_eq!","","Generate a test function `$name` which asserts that `$left` and `$right`\nare equal.",null,null],[14,"addrs_of!","","Make a tuple of the addresses of some of a struct's fields.",null,null],[14,"format_if!","","Conditionally perform string formatting.",null,null],[14,"ext_bail!","","Call `span_err` on an `ExtCtxt` and return `DummyResult::any`.",null,null],[14,"ext_bail_if!","","`ext_bail!` if the condition `$e` is true.",null,null],[14,"ext_expect!","","Unwrap the `Option` `$e`, or `ext_bail!`.",null,null],[14,"matches!","","Returns true if an expression matches a pattern.",null,null],[14,"unwrap_or_return!","","Unwraps an `Option` or returns from the function with the specified return\nvalue.",null,null],[14,"do_while!","","Do-while loop.",null,null]],"paths":[]};
initSearch(searchIndex);
