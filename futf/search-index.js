var searchIndex = {};
searchIndex['futf'] = {"items":[[0,"","futf","",null,null],[3,"Codepoint","","Represents a complete or partial UTF-8 codepoint.",null,null],[12,"bytes","","The bytes that make up the partial or full codepoint.",0,null],[12,"rewind","","Start of the codepoint in the buffer, expressed as an offset\nback from `idx`.",0,null],[12,"meaning","","Meaning of the partial or full codepoint.",0,null],[4,"Meaning","","Meaning of a complete or partial UTF-8 codepoint.",null,null],[13,"Whole","","We found a whole codepoint.",1,null],[13,"LeadSurrogate","","We found something that isn't a valid Unicode codepoint, but\nit *would* correspond to a UTF-16 leading surrogate code unit,\ni.e. a value in the range `U+D800` - `U+DBFF`.",1,null],[13,"TrailSurrogate","","We found something that isn't a valid Unicode codepoint, but\nit *would* correspond to a UTF-16 trailing surrogate code unit,\ni.e. a value in the range `U+DC00` - `U+DFFF`.",1,null],[13,"Prefix","","We found only a prefix of a codepoint before the buffer ended.",1,null],[13,"Suffix","","We found only a suffix of a codepoint before running off the\nstart of the buffer.",1,null],[5,"classify","","Describes the UTF-8 codepoint containing the byte at index `idx` within\n`buf`.",null,null],[11,"hash","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"meaning"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"meaning"}],"output":{"name":"meaning"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"codepoint"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"codepoint"}],"output":{"name":"codepoint"}}]],"paths":[[3,"Codepoint"],[4,"Meaning"]]};
searchIndex['mac'] = {"items":[[0,"","mac","# mac",null,null],[0,"test","","Macros for writing test suites.",null,null],[0,"mem","","Macros for low-level memory manipulation.",null,null],[0,"format","","Macros for string formatting.",null,null],[0,"syntax_ext","","Macros useful when writing procedural syntax extensions.",null,null],[0,"matches","","Pattern Matching macros.",null,null],[14,"test_eq!","","Generate a test function `$name` which asserts that `$left` and `$right`\nare equal.",null,null],[14,"addrs_of!","","Make a tuple of the addresses of some of a struct's fields.",null,null],[14,"format_if!","","Conditionally perform string formatting.",null,null],[14,"ext_bail!","","Call `span_err` on an `ExtCtxt` and return `DummyResult::any`.",null,null],[14,"ext_bail_if!","","`ext_bail!` if the condition `$e` is true.",null,null],[14,"ext_expect!","","Unwrap the `Option` `$e`, or `ext_bail!`.",null,null],[14,"matches!","","Returns true if an expression matches a pattern.",null,null],[14,"unwrap_or_return!","","Unwraps an `Option` or returns from the function with the specified return\nvalue.",null,null],[14,"do_while!","","Do-while loop.",null,null]],"paths":[]};
initSearch(searchIndex);
