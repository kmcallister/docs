var searchIndex = {};
searchIndex['futf'] = {"items":[[0,"","futf","",null,null],[3,"Codepoint","","Represents a complete or partial UTF-8 codepoint.",null,null],[12,"bytes","","The bytes that make up the partial or full codepoint.",0,null],[12,"rewind","","Start of the codepoint in the buffer, expressed as an offset\nback from `idx`.",0,null],[12,"meaning","","Meaning of the partial or full codepoint.",0,null],[4,"Meaning","","Meaning of a complete or partial UTF-8 codepoint.",null,null],[13,"Whole","","We found a whole codepoint.",1,null],[13,"LeadSurrogate","","We found something that isn't a valid Unicode codepoint, but\nit *would* correspond to a UTF-16 leading surrogate code unit,\ni.e. a value in the range `U+D800` - `U+DBFF`.",1,null],[13,"TrailSurrogate","","We found something that isn't a valid Unicode codepoint, but\nit *would* correspond to a UTF-16 trailing surrogate code unit,\ni.e. a value in the range `U+DC00` - `U+DFFF`.",1,null],[13,"Prefix","","We found only a prefix of a codepoint before the buffer ended.",1,null],[13,"Suffix","","We found only a suffix of a codepoint before running off the\nstart of the buffer.",1,null],[5,"classify","","Describes the UTF-8 codepoint containing the byte at index `idx` within\n`buf`.",null,null],[11,"hash","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"meaning"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"meaning"},{"name":"meaning"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"meaning"}],"output":{"name":"meaning"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"codepoint"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cmp","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"codepoint"},{"name":"codepoint"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"codepoint"}],"output":{"name":"codepoint"}}]],"paths":[[3,"Codepoint"],[4,"Meaning"]]};
searchIndex['debug_unreachable'] = {"items":[[0,"","debug_unreachable","`panic!()` in debug builds, optimization hint in release.",null,null],[5,"__unreachable","","Hint to the optimizer that any code path which calls this function is\nstatically unreachable and can be removed.",null,null],[14,"debug_unreachable!","","`panic!()` in debug builds, optimization hint in release.",null,null]],"paths":[]};
searchIndex['unreachable'] = {"items":[[0,"","unreachable","# unreachable",null,null],[5,"unreachable","","Hint to the optimizer that any code path which calls this function is\nstatically unreachable and can be removed.",null,{"inputs":[],"output":null}],[8,"UncheckedOptionExt","","An extension trait for `Option<T>` providing unchecked unwrapping methods.",null,null],[10,"unchecked_unwrap","","Get the value out of this Option without checking for None.",0,{"inputs":[{"name":"uncheckedoptionext"}],"output":{"name":"t"}}],[10,"unchecked_unwrap_none","","Assert that this Option is a None to the optimizer.",0,{"inputs":[{"name":"uncheckedoptionext"}],"output":null}],[8,"UncheckedResultExt","","An extension trait for `Result<T, E>` providing unchecked unwrapping methods.",null,null],[10,"unchecked_unwrap_ok","","Get the value out of this Result without checking for Err.",1,{"inputs":[{"name":"uncheckedresultext"}],"output":{"name":"t"}}],[10,"unchecked_unwrap_err","","Get the error out of this Result without checking for Ok.",1,{"inputs":[{"name":"uncheckedresultext"}],"output":{"name":"e"}}],[11,"unchecked_unwrap","core::option","",2,{"inputs":[{"name":"option"}],"output":{"name":"t"}}],[11,"unchecked_unwrap_none","","",2,{"inputs":[{"name":"option"}],"output":null}],[11,"unchecked_unwrap_ok","core::result","",3,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[11,"unchecked_unwrap_err","","",3,{"inputs":[{"name":"result"}],"output":{"name":"e"}}]],"paths":[[8,"UncheckedOptionExt"],[8,"UncheckedResultExt"],[4,"Option"],[4,"Result"]]};
searchIndex['void'] = {"items":[[0,"","void","# Void",null,null],[4,"Void","","The empty type for cases which can't occur.",null,null],[5,"unreachable","","A safe version of `intrinsincs::unreachable`.",null,{"inputs":[{"name":"void"}],"output":null}],[8,"ResultVoidExt","","Extensions to `Result<T, Void>`",null,null],[10,"void_unwrap","","Get the value out of a wrapper.",0,{"inputs":[{"name":"resultvoidext"}],"output":{"name":"t"}}],[8,"ResultVoidErrExt","","Extensions to `Result<Void, E>`",null,null],[10,"void_unwrap_err","","Get the error out of a wrapper.",1,{"inputs":[{"name":"resultvoiderrext"}],"output":{"name":"e"}}],[11,"clone","","",2,{"inputs":[{"name":"void"}],"output":{"name":"void"}}],[11,"fmt","","",2,{"inputs":[{"name":"void"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"void"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"void"},{"name":"t"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"void"},{"name":"t"}],"output":{"name":"option"}}],[11,"description","","",2,{"inputs":[{"name":"void"}],"output":{"name":"str"}}],[11,"cause","","",2,{"inputs":[{"name":"void"}],"output":{"name":"option"}}],[11,"void_unwrap","core::result","Get the value out of an always-ok Result.",3,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[11,"void_unwrap_err","","Get the error out of an always-err Result.",3,{"inputs":[{"name":"result"}],"output":{"name":"e"}}]],"paths":[[8,"ResultVoidExt"],[8,"ResultVoidErrExt"],[4,"Void"],[4,"Result"]]};
searchIndex['mac'] = {"items":[[0,"","mac","# mac",null,null],[0,"test","","Macros for writing test suites.",null,null],[0,"mem","","Macros for low-level memory manipulation.",null,null],[0,"format","","Macros for string formatting.",null,null],[0,"syntax_ext","","Macros useful when writing procedural syntax extensions.",null,null],[0,"matches","","Pattern Matching macros.",null,null],[14,"test_eq!","","Generate a test function `$name` which asserts that `$left` and `$right`\nare equal.",null,null],[14,"addrs_of!","","Make a tuple of the addresses of some of a struct's fields.",null,null],[14,"format_if!","","Conditionally perform string formatting.",null,null],[14,"ext_bail!","","Call `span_err` on an `ExtCtxt` and return `DummyResult::any`.",null,null],[14,"ext_bail_if!","","`ext_bail!` if the condition `$e` is true.",null,null],[14,"ext_expect!","","Unwrap the `Option` `$e`, or `ext_bail!`.",null,null],[14,"matches!","","Returns true if an expression matches a pattern.",null,null],[14,"unwrap_or_return!","","Unwraps an `Option` or returns from the function with the specified return\nvalue.",null,null],[14,"do_while!","","Do-while loop.",null,null]],"paths":[]};
initSearch(searchIndex);
